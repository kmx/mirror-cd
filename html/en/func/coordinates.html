<!doctype HTML PUBLIC "-//IETF//DTD HTML//EN">
<html>

<head>
<meta http-equiv="Content-Language" content="en-us">
<meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
<title>Coordinate System</title>
<link rel="stylesheet" type="text/css" href="../../style.css">
</head>

<body>

<h2 align="center">Coordinate System</h2>
<div class="function"><pre class="function"><span class="mainFunction">void&nbsp;<a name="cdGetCanvasSize">cdCanvasGetSize</a>(cdCanvas* canvas, int *width, int *height, double *width_mm, double *height_mm); [in C]</span>

canvas:GetSize() -&gt; (width, height, mm_width, mm_height: number) [in Lua]</pre>

  <p>Returns the canvas size in pixels and in millimeters. You can provide only 
  the desired values and <font>NULL</font> for the others.</p>

</div><div class="function"><pre class="function"><span class="mainFunction">int&nbsp;<a name="cdYAxisMode">cdCanvasYAxisMode</a>(cdCanvas* canvas, int invert); [in C]</span>

canvas:YAxisMode(invert: number) -&gt; (old_invert: number) [in Lua]</pre>

  <p>Controls the orientation of the Y axis. Internally in some drivers the 
	native axis orientation is top-bottom, so the CD primitives must invert the 
	Y axis since the CD orientation is bottom-top. Using CD_QUERY will return 
	the current Y axis mode, if needs to be invert or not. Using 1 or 0 you can 
	control if the Y axis should be inverted or not independent from the native 
	orientation, with that you can in fact invert the orientation of the CD 
	primitives.</p>

</div><div class="function"><pre class="function"><span class="mainFunction">int&nbsp;<a name="cdUpdateYAxis">cdCanvasUpdateYAxis</a>(cdCanvas* canvas, int *y); [in C]</span>
double&nbsp;cdfCanvasUpdateYAxis(cdCanvas* canvas, double&nbsp;*y); [in C]
int&nbsp;cdCanvasInvertYAxis(cdCanvas* canvas, int y); [in C]
double&nbsp;cdfCanvasInvertYAxis(cdCanvas* canvas, double&nbsp;y); [in C]

canvas:UpdateYAxis(yc: number) -&gt; (yr: number) [in Lua]
canvas:InvertYAxis(yc: number) -&gt; (yr: number) [in Lua]</pre>

  <p>Converts the coordinate system of the CD library into the internal 
  system of the active canvas' driver, and the other way round, if they are 
	invert, or else do nothing. This is just <font>&quot;y = height-1 - 
  y&quot;</font>. It returns the changed value. The &quot;Invert&quot; will always invert 
  the given value, the &quot;Update&quot; function will invert only if the canvas has the 
  Y axis inverted.</p>

</div><div class="function"><pre class="function"><span class="mainFunction">void&nbsp;cdCanvasMM2Pixel(cdCanvas* canvas, double mm_dx, double mm_dy, int *dx, int *dy); [in C]</span>
void&nbsp;cdfCanvasMM2Pixel(cdCanvas* canvas, double mm_dx, double mm_dy, double *dx, double *dy); [in C]

canvas:MM2Pixel(mm_dx, mm_dy: number) -&gt; (dx, dy: number) [in Lua]
canvas:fMM2Pixel(mm_dx, mm_dy: number) -&gt; (dx, dy: number) [in Lua]</pre>

  <p>Converts sizes in millimeters into pixels (canvas coordinates). You can 
  provide only the desired values and <font>NULL</font> for the 
  others.</p>

</div><div class="function"><pre class="function"><span class="mainFunction">void&nbsp;cdCanvasPixel2MM(cdCanvas* canvas, int dx, int dy, double *mm_dx, double *mm_dy); [in C]</span>
void&nbsp;cdfCanvasPixel2MM(cdCanvas* canvas, double dx, double dy, double *mm_dx, double *mm_dy); [in C]

canvas:Pixel2MM(dx, dy: number) -&gt; (mm_dx, mm_dy: number) [in Lua]
canvas:fPixel2MM(dx, dy: number) -&gt; (mm_dx, mm_dy: number) [in Lua]</pre>

  <p>Converts sizes in pixels (canvas coordinates) into millimeters. You can 
  provide only the desired values and <font>NULL</font> for the 
  others. Use this function to obtain the horizontal and vertical resolution of 
  the canvas by passing 1 as parameter in <font>dx</font> and
  <font>dy</font>. The resolution value is obtained using the 
  formula <strong><font>res=1.0/mm</font></strong>.</p>

</div><div class="function"><pre class="function"><span class="mainFunction">void&nbsp;cdCanvasOrigin(cdCanvas* canvas, int x, int y); [in C]</span>
void&nbsp;cdfCanvasOrigin(cdCanvas* canvas, double x, double y); [in C]

canvas:Origin(x, y: number) [in Lua]
canvas:fOrigin(x, y: number) [in Lua]</pre>

  <p>Allows translating the origin - for instance, to the center of the canvas. 
  The function profits from the architecture of the library to simulate a 
  translation of the origin, which in fact is never actually passed to the 
  canvas in the respective driver. Default values: (0, 0)</p>


</div><div class="function"><pre class="function"><span class="mainFunction">void&nbsp;cdCanvasGetOrigin(cdCanvas* canvas, int *x, int *y); [in C]</span>
void&nbsp;cdfCanvasGetOrigin(cdCanvas* canvas, double *x, double *y); [in C]

canvas:GetOrigin() -&gt; (x, y: number) [in Lua]
canvas:fGetOrigin() -&gt; (x, y: number) [in Lua]</pre>

  <p>Returns the origin.</p>

</div>
<h3>Transformation Matrix</h3>

<div class="function"><pre class="function"><span class="mainFunction">void&nbsp;<a name="cdTransform">cdCanvasTransform</a>(cdCanvas* canvas, const double* matrix); [in C]</span>

canvas:Transform(matrix: table) [in Lua]</pre>

    <p>Defines a transformation matrix with 6 elements. If the matrix is NULL, 
    the 
      transformation is reset to the identity. Default value: NULL.</p>
    <p>The matrix contains scale, rotation and translation elements as follows:</p>
    <pre>|x'|   |sx*cos(angle)    -sin(angle)  dx|   |x|                     |0   2   4| 
|y'| = |   sin(angle)  sy*cos(angle)  dy| * |y|      with indices   |1   3   5|
                                            |1|</pre>
  <p>But notice that the indices are different of the <strong>
  cdCanvasVectorTextTransform</strong>.</p>
<p>Functions that retrieve images from the canvas are not affected by the 
transformation matrix, such as <strong>GetImage</strong>, <strong>GetImageRGB</strong> 
and <strong>ScrollArea</strong>.</p>
<p>Transformation matrix is independent of the <strong>World Coordinate</strong> 
and <strong>Origin</strong> 
functions. And those are affected if a transformation is set, just like other 
regular primitives.</p>


</div><div class="function"><pre class="function"><span class="mainFunction">double*&nbsp;<a name="cdGetTransform">cdCanvasGetTransform</a>(cdCanvas* canvas); [in C]</span>

canvas:GetTransformation() -&gt; (matrix: table) [in Lua]</pre>

  <p>Returns the transformation matrix. If the identity is set, returns NULL.</p>


</div><div class="function"><pre class="function"><span class="mainFunction">void&nbsp;<a name="cdTransformMultiply">cdCanvasTransforMultiply</a>(cdCanvas* canvas, const double* matrix); [in C]</span>

canvas:TransformMultiply(matrix: table) [in Lua]</pre>

    <p>Left multiply the current transformation by the given transformation.</p>

</div><div class="function"><pre class="function"><span class="mainFunction">void&nbsp;<a name="cdTransformTranslate">cdCanvasTransformTranslate</a>(cdCanvas* canvas, double dx, double dy); [in C]</span>

canvas:TransformTranslate(dx, dy: number) [in Lua]</pre>

    <p>Applies a translation to the current transformation.</p>

</div><div class="function"><pre class="function"><span class="mainFunction">void&nbsp;<a name="cdTransformScale">cdCanvasTransformScale</a>(cdCanvas* canvas, double sx, double sy); [in C]</span>

canvas:TransformScale(sx, sy: number) [in Lua]</pre>

    <p>Applies a scale to the current transformation.</p>

</div><div class="function"><pre class="function"><span class="mainFunction">void&nbsp;<a name="cdTransformRotate">cdCanvasTransformRotate</a>(cdCanvas* canvas, double angle); [in C]</span>

canvas:TransformRotate(angle: number) [in Lua]</pre>

    <p>Applies a rotation to the current transformation. Angle is in degrees, 
    oriented counter-clockwise from the horizontal axis.</p>

</div><div class="function"><pre class="function"><span class="mainFunction">void&nbsp;<a name="cdTransformPoint">cdCanvasTransformPoint</a>(cdCanvas* canvas, int x, int y, int *tx, int *ty); [in C]</span>
void cdfCanvasTransformPoint(cdCanvas* canvas, double x, double y, double *tx, double *ty); [in C]

canvas:TransformPoint(x, y: number) -&gt; (tx, ty: number) [in Lua]
canvas:fTransformPoint(x, y: number) -&gt; (tx, ty: number) [in Lua]</pre>

    <p>Applies a transformation to a given point.</p>
</div>
</body>

</html>